{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Home \u00b6 Website provides a list of notes around network and automation. More to come later","title":"Home"},{"location":"#home","text":"Website provides a list of notes around network and automation. More to come later","title":"Home"},{"location":"yaml-jinja/","text":"YAML Structures in Jinja2 \u00b6 Data structure to use YAML with JINJA2 templates. YAML keeps data stored as a map containing keys and values associated to those keys. Basic \u00b6 Generic key allocation \u00b6 YAML input data structure --- time_zone : Europe/Paris hostname : myDevice comment : \u201cThis device is a fake one\u201d JINJA2 to consume YAML data structure system { {% if time_zone is defined %} time-zone {{ time_zone }}; {% endif %} Structured key allocation \u00b6 YAML will consider lines prefixed with more spaces than parent key are contained inside it --- routing_policy : communities : myCommunity : target:99:1 tenant2 : target:99:2 Data structure similar to this YAML representation is : routing_policy = { \"communities\" : { \"myCommunity\" : \"target:99:1\" , \"tenant2\" : \"target:99:2\" } } List Management \u00b6 YAML List \u00b6 Assuming following data structure in YAML --- ntp_servers : - 8.8.8.8 - 4.4.4.4 Access data from JINJA2 can be done with the following code: {% for ntp_server in ntp_servers %} server {{ ntp_server }}; {% endfor %} Data structure similar to this YAML representation is : ntp_servers = [ '8.8.8.8' , '4.4.4.4' ] YAML Dictionary \u00b6 Assuming following data structure in YAML --- vlans : 10 : name1 20 : name2 30 : name3 Access data from JINJA2 can be done with the following code: {% for vlan_id, name in vlans.items() %} vlan {{ vlan_id }} name {{ name }} {% endfor %} Data structure similar to this YAML representation is : vlans = { 10 : \"name1\" , 20 : \"name2\" , 30 : \"name3\" } YAML Maps \u00b6 Assuming following data structure in YAML --- interfaces : - name : \"ge-0/0/0\" descr : \"Blah\" - name : \"ge-0/0/1\" descr : \"comment\" Access data from JINJA2 can be done with the following code: {% for interface in interfaces %} {{interface.name}} { description {{interface.descr}}; vlan-tagging; {% endfor %} Data structure similar to this YAML representation is : interfaces = [{ \"name\" : \"ge-0/0/0\" , \"descr\" : \"Blah\" }, { \"name\" : \"ge-0/0/1\" , \"descr\" : \"comment\" }] Advanced Jinja2 syntax \u00b6 Update variable in a Loop \u00b6 Syntax below allows user to update value of a variable within a loop and access to it after in a different jinja2 block: {% set ns = namespace (dev_state = \"disable\") %} {% for portname, portlist in topo[inventory_hostname].iteritems() %} {% if portlist.state == \"enable\" %} {% set ns.dev_state = \"enable\" %} {% endif %} {% endfor %} status: {{ns.dev_state|default(\"enable\")}} Use IPaddr within Jinja2 template \u00b6 Assuming following yaml definition: id : 10 underlay : networks : loopbacks : 10.0.0.0/16 Jinja gives option to build IP address within loopback network with following syntax where id is the idth in the network: loopback_ip: {{ underlay.networks.loopbacks | ipaddr(id) | ipaddr('address') }} Another example: {{ tenant.interconnect_prefix | ipaddr(6)}} combined with interconnect_prefix: 172.25.10.16/28 resulst in 172.25.10.22 Manage Jinja2 rendering indentation \u00b6 Jinja2 can manage whitespace and tabular indentation with lstrip_blocks and trim_blocks options: trim_blocks : If this is set to True the first newline after a block is removed (block, not variable tag!). Defaults to False . lstrip_blocks : If this is set to True leading spaces and tabs are stripped from the start of a line to a block. Defaults to False . To manage these options, just put this line in your template: #jinja2: lstrip_blocks: \"True (or False)\", trim_blocks: \"True (or False)\" ... Example Using this template: {% for host in groups['webservers'] %} {% if inventory_hostname in hostvars[host]['ansible_fqdn'] %} {{ hostvars[host]['ansible_default_ipv4']['address'] }} {{ hostvars[host]['ansible_fqdn'] }} {{ hostvars[host]['inventory_hostname'] }} MYSELF {% else %} {{ hostvars[host]['ansible_default_ipv4']['address'] }} {{ hostvars[host]['ansible_fqdn'] }} jcs-server{{ loop.index }} {{ hostvars[host]['inventory_hostname'] }} {% endif %} {% endfor %} lstrip_block=False Rendering is similar to : 172.16.25.1 spine1 172.16.25.3 spine2 172.16.25.4 spine3 lstrip_block=true Rendering should be: 172.16.25.1 spine1 172.16.25.3 spine2 172.16.25.4 spine3 Loop management \u00b6 Jinja2 has built-in option to manage loop information: Variable Description loop.index The current iteration of the loop. (1 indexed) loop.index0 The current iteration of the loop. (0 indexed) loop.revindex The number of iterations from the end of the loop (1 indexed) loop.revindex0 The number of iterations from the end of the loop (0 indexed) loop.first True if first iteration. loop.last True if last iteration. loop.length The number of items in the sequence. loop.cycle A helper function to cycle between a list of sequences. See the explanation below. loop.depth Indicates how deep in deep in a recursive loop the rendering currently is. Starts at level 1 loop.depth0 Indicates how deep in deep in a recursive loop the rendering currently is. Starts at level 0","title":"YAML Structures in Jinja2"},{"location":"yaml-jinja/#yaml-structures-in-jinja2","text":"Data structure to use YAML with JINJA2 templates. YAML keeps data stored as a map containing keys and values associated to those keys.","title":"YAML Structures in Jinja2"},{"location":"yaml-jinja/#basic","text":"","title":"Basic"},{"location":"yaml-jinja/#generic-key-allocation","text":"YAML input data structure --- time_zone : Europe/Paris hostname : myDevice comment : \u201cThis device is a fake one\u201d JINJA2 to consume YAML data structure system { {% if time_zone is defined %} time-zone {{ time_zone }}; {% endif %}","title":"Generic key allocation"},{"location":"yaml-jinja/#structured-key-allocation","text":"YAML will consider lines prefixed with more spaces than parent key are contained inside it --- routing_policy : communities : myCommunity : target:99:1 tenant2 : target:99:2 Data structure similar to this YAML representation is : routing_policy = { \"communities\" : { \"myCommunity\" : \"target:99:1\" , \"tenant2\" : \"target:99:2\" } }","title":"Structured key allocation"},{"location":"yaml-jinja/#list-management","text":"","title":"List Management"},{"location":"yaml-jinja/#yaml-list","text":"Assuming following data structure in YAML --- ntp_servers : - 8.8.8.8 - 4.4.4.4 Access data from JINJA2 can be done with the following code: {% for ntp_server in ntp_servers %} server {{ ntp_server }}; {% endfor %} Data structure similar to this YAML representation is : ntp_servers = [ '8.8.8.8' , '4.4.4.4' ]","title":"YAML List"},{"location":"yaml-jinja/#yaml-dictionary","text":"Assuming following data structure in YAML --- vlans : 10 : name1 20 : name2 30 : name3 Access data from JINJA2 can be done with the following code: {% for vlan_id, name in vlans.items() %} vlan {{ vlan_id }} name {{ name }} {% endfor %} Data structure similar to this YAML representation is : vlans = { 10 : \"name1\" , 20 : \"name2\" , 30 : \"name3\" }","title":"YAML Dictionary"},{"location":"yaml-jinja/#yaml-maps","text":"Assuming following data structure in YAML --- interfaces : - name : \"ge-0/0/0\" descr : \"Blah\" - name : \"ge-0/0/1\" descr : \"comment\" Access data from JINJA2 can be done with the following code: {% for interface in interfaces %} {{interface.name}} { description {{interface.descr}}; vlan-tagging; {% endfor %} Data structure similar to this YAML representation is : interfaces = [{ \"name\" : \"ge-0/0/0\" , \"descr\" : \"Blah\" }, { \"name\" : \"ge-0/0/1\" , \"descr\" : \"comment\" }]","title":"YAML Maps"},{"location":"yaml-jinja/#advanced-jinja2-syntax","text":"","title":"Advanced Jinja2 syntax"},{"location":"yaml-jinja/#update-variable-in-a-loop","text":"Syntax below allows user to update value of a variable within a loop and access to it after in a different jinja2 block: {% set ns = namespace (dev_state = \"disable\") %} {% for portname, portlist in topo[inventory_hostname].iteritems() %} {% if portlist.state == \"enable\" %} {% set ns.dev_state = \"enable\" %} {% endif %} {% endfor %} status: {{ns.dev_state|default(\"enable\")}}","title":"Update variable in a Loop"},{"location":"yaml-jinja/#use-ipaddr-within-jinja2-template","text":"Assuming following yaml definition: id : 10 underlay : networks : loopbacks : 10.0.0.0/16 Jinja gives option to build IP address within loopback network with following syntax where id is the idth in the network: loopback_ip: {{ underlay.networks.loopbacks | ipaddr(id) | ipaddr('address') }} Another example: {{ tenant.interconnect_prefix | ipaddr(6)}} combined with interconnect_prefix: 172.25.10.16/28 resulst in 172.25.10.22","title":"Use IPaddr within Jinja2 template"},{"location":"yaml-jinja/#manage-jinja2-rendering-indentation","text":"Jinja2 can manage whitespace and tabular indentation with lstrip_blocks and trim_blocks options: trim_blocks : If this is set to True the first newline after a block is removed (block, not variable tag!). Defaults to False . lstrip_blocks : If this is set to True leading spaces and tabs are stripped from the start of a line to a block. Defaults to False . To manage these options, just put this line in your template: #jinja2: lstrip_blocks: \"True (or False)\", trim_blocks: \"True (or False)\" ... Example Using this template: {% for host in groups['webservers'] %} {% if inventory_hostname in hostvars[host]['ansible_fqdn'] %} {{ hostvars[host]['ansible_default_ipv4']['address'] }} {{ hostvars[host]['ansible_fqdn'] }} {{ hostvars[host]['inventory_hostname'] }} MYSELF {% else %} {{ hostvars[host]['ansible_default_ipv4']['address'] }} {{ hostvars[host]['ansible_fqdn'] }} jcs-server{{ loop.index }} {{ hostvars[host]['inventory_hostname'] }} {% endif %} {% endfor %} lstrip_block=False Rendering is similar to : 172.16.25.1 spine1 172.16.25.3 spine2 172.16.25.4 spine3 lstrip_block=true Rendering should be: 172.16.25.1 spine1 172.16.25.3 spine2 172.16.25.4 spine3","title":"Manage Jinja2 rendering indentation"},{"location":"yaml-jinja/#loop-management","text":"Jinja2 has built-in option to manage loop information: Variable Description loop.index The current iteration of the loop. (1 indexed) loop.index0 The current iteration of the loop. (0 indexed) loop.revindex The number of iterations from the end of the loop (1 indexed) loop.revindex0 The number of iterations from the end of the loop (0 indexed) loop.first True if first iteration. loop.last True if last iteration. loop.length The number of items in the sequence. loop.cycle A helper function to cycle between a list of sequences. See the explanation below. loop.depth Indicates how deep in deep in a recursive loop the rendering currently is. Starts at level 1 loop.depth0 Indicates how deep in deep in a recursive loop the rendering currently is. Starts at level 0","title":"Loop management"},{"location":"how-to/ci-to-start-docker-and-validate-code/","text":"Continuous Intgration with Docker interactions \u00b6 This article explains how to configure gitlabci runners to run your code and provision target to validate your code. Note: Docker is a requirement on your host device to both run gitlab runner and your project. Configure a gitlab ci runner \u00b6 First step is to configure a gitlab runner and connect it to your projet. Gitlab provides a docker image to deploy their runner. It is available on this page . A default command to start a runner is the following: $ docker run -d --name gitlab-runner \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest This command starts a docker gitlabci runner and share following folder with host filesystem: /var/run/docker.sock is bind to the same path within container In this scenario, configuration is not permanent and will be deleted after we stop the container. And especially configuration related to gitlabci service. To make it permanent, add following line to previous command: $ mkdir -p /home/docker/gitlab-runner $ docker run -d --name gitlab-runner \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /home/docker/gitlab-runner:/etc/gitlab-runner \\ gitlab/gitlab-runner:latest Then, we have to register runner to your gitlab project. Go to https://gitlab.your.server.com/your-namespace/your-project/settings/ci_cd and note both your token and URL Once you have these information, we can register the runner with following command: docker exec -it gitlab-runner gitlab-runner register \\ --non-interactive \\ --url $gitlab .your.server.com$ \\ --registration-token $TOKEN $ \\ --executor \"docker\" \\ --docker-image alpine:3 \\ --description \"docker-runner\" \\ --tag-list $YOUR_TAG \\ --docker-volumes /var/run/docker.sock:/var/run/docker.sock \\ --run-untagged \\ --locked = \"false\"","title":"Continuous Intgration with Docker interactions"},{"location":"how-to/ci-to-start-docker-and-validate-code/#continuous-intgration-with-docker-interactions","text":"This article explains how to configure gitlabci runners to run your code and provision target to validate your code. Note: Docker is a requirement on your host device to both run gitlab runner and your project.","title":"Continuous Intgration with Docker interactions"},{"location":"how-to/ci-to-start-docker-and-validate-code/#configure-a-gitlab-ci-runner","text":"First step is to configure a gitlab runner and connect it to your projet. Gitlab provides a docker image to deploy their runner. It is available on this page . A default command to start a runner is the following: $ docker run -d --name gitlab-runner \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest This command starts a docker gitlabci runner and share following folder with host filesystem: /var/run/docker.sock is bind to the same path within container In this scenario, configuration is not permanent and will be deleted after we stop the container. And especially configuration related to gitlabci service. To make it permanent, add following line to previous command: $ mkdir -p /home/docker/gitlab-runner $ docker run -d --name gitlab-runner \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v /home/docker/gitlab-runner:/etc/gitlab-runner \\ gitlab/gitlab-runner:latest Then, we have to register runner to your gitlab project. Go to https://gitlab.your.server.com/your-namespace/your-project/settings/ci_cd and note both your token and URL Once you have these information, we can register the runner with following command: docker exec -it gitlab-runner gitlab-runner register \\ --non-interactive \\ --url $gitlab .your.server.com$ \\ --registration-token $TOKEN $ \\ --executor \"docker\" \\ --docker-image alpine:3 \\ --description \"docker-runner\" \\ --tag-list $YOUR_TAG \\ --docker-volumes /var/run/docker.sock:/var/run/docker.sock \\ --run-untagged \\ --locked = \"false\"","title":"Configure a gitlab ci runner"},{"location":"how-to/docker-ansible/","text":"Ansible using docker \u00b6 This how-to explains how to configure docker and your shell environment to execute ansible within a container and not from your system. It is useful to use this approach to validate code with different ansible version. Github repository : titom73/docker-ansible Docker Image : inetsix/docker-ansible Repository we use in this example gives us option to: share your ssh agent with the ansible docker share your AWS CLI configuration Use a specifc version without installation Use AWS and Junos componants: aws cli , junos-eznc , Juniper.junos ansible module Just add these aliases to your ~/.{bash|zsh|...}_aliases in order to use ansible as it where installed on your computer. export DOCKER_ANSIBLE_VERSION = 2 .5 base_ansible () { docker run -it --rm \\ --volume $SSH_AUTH_SOCK :/ssh-agent \\ --env SSH_AUTH_SOCK = /ssh-agent \\ -v ${ PWD } :project \\ -v ${ HOME } /.ssh/known_hosts:/root/.ssh/known_hosts \\ -w ${ PWD } \\ inetsix/docker-ansible: ${ DOCKER_ANSIBLE_VERSION } $@ } Once this bash function is available, you can build you aliases to mimic ansible: alias ansible-update = 'docker pull inetsix/docker-ansible:${DOCKER_ANSIBLE_VERSION}' alias ansible-shell = 'base_ansible bash' alias ansible = 'base_ansible ansible' alias ansible-playbook = 'base_ansible ansible-playbook' alias ansible-vault = 'base_ansible ansible-vault' alias ansible-galaxy = 'base_ansible ansible-galaxy' The export statement gives option to specify which version of ansible we want to use. This version is equal to tags defined during the build This docker image is built with the following tags (12/2018) for both alpine and Debian jessie OS: latest 2.3 2.4 2.5 2.6 2.7 Usage \u00b6 Simply use your aliases, and you can override ansible default version when required $ DOCKER_ANSIBLE_VERSION = 2 .5 $ docker-ansible --version ansible 2 .5.2 config file = /Users/titom73/Scripting/ansible.projects/ansible.training.phase2/ansible.cfg configured module search path = [ u '/root/.ansible/plugins/modules' , \\ u '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/local/lib/python2.7/site-packages/ansible executable location = /usr/local/bin/ansible python version = 2 .7.14 ( default, Apr 27 2018 , 09 :37:08 ) [ GCC 4 .9.2 ] Optional parameters \u00b6 Export AWS CLI parameters \u00b6 Assuming you have configured your AWS CLI, you may export your parameters with the following variables: On your local shell: export AWS_DEFAULT_REGION = 'eu-west-2' export AWS_PROFILE = 'your_aws_profile' Then, these variables are exposed to your docker instance by using --env keyword. If they are not set, then, nothing is export to your container. export DOCKER_ANSIBLE_VERSION = 2 .5 base_ansible () { docker run -it --rm \\ --env ANSIBLE_REMOTE_USER = ${ USER } \\ --env AWS_DEFAULT_REGION = ${ AWS_DEFAULT_REGION } \\ --env AWS_PROFILE = ${ AWS_PROFILE } \\ --volume $SSH_AUTH_SOCK :/ssh-agent \\ --env SSH_AUTH_SOCK = /ssh-agent \\ -v ${ PWD } :project \\ -v ${ HOME } /.aws/:/root/.aws/ \\ -v ${ HOME } /.ssh/known_hosts:/root/.ssh/known_hosts \\ -w ${ PWD } \\ inetsix/docker-ansible: ${ DOCKER_ANSIBLE_VERSION } $@ } Overwrite ansible commands \u00b6 If for some reasons, you need to use your installed ansible version, just use \\\\ in front of any ansible command like below: $ \\a nsible --version ansible 2 .5.1 config file = /Users/titom73/Scripting/ansible.projects/ansible.training.phase2/ansible.cfg configured module search path = [ u '/Users/titom73/.ansible/plugins/modules' , \\ u '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/local/lib/python2.7/site-packages/ansible executable location = /usr/local/bin/ansible python version = 2 .7.14 ( default, Mar 22 2018 , 15 :04:47 ) \\ [ GCC 4 .2.1 Compatible Apple LLVM 9 .0.0 ( clang-900.0.39.2 )] $ ansible --version ansible 2 .5.2 config file = /Users/titom73/Scripting/ansible.projects/ansible.training.phase2/ansible.cfg configured module search path = [ u '/root/.ansible/plugins/modules' , \\ u '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/local/lib/python2.7/site-packages/ansible executable location = /usr/local/bin/ansible python version = 2 .7.14 ( default, Apr 27 2018 , 09 :37:08 ) [ GCC 4 .9.2 ]","title":"Ansible using docker"},{"location":"how-to/docker-ansible/#ansible-using-docker","text":"This how-to explains how to configure docker and your shell environment to execute ansible within a container and not from your system. It is useful to use this approach to validate code with different ansible version. Github repository : titom73/docker-ansible Docker Image : inetsix/docker-ansible Repository we use in this example gives us option to: share your ssh agent with the ansible docker share your AWS CLI configuration Use a specifc version without installation Use AWS and Junos componants: aws cli , junos-eznc , Juniper.junos ansible module Just add these aliases to your ~/.{bash|zsh|...}_aliases in order to use ansible as it where installed on your computer. export DOCKER_ANSIBLE_VERSION = 2 .5 base_ansible () { docker run -it --rm \\ --volume $SSH_AUTH_SOCK :/ssh-agent \\ --env SSH_AUTH_SOCK = /ssh-agent \\ -v ${ PWD } :project \\ -v ${ HOME } /.ssh/known_hosts:/root/.ssh/known_hosts \\ -w ${ PWD } \\ inetsix/docker-ansible: ${ DOCKER_ANSIBLE_VERSION } $@ } Once this bash function is available, you can build you aliases to mimic ansible: alias ansible-update = 'docker pull inetsix/docker-ansible:${DOCKER_ANSIBLE_VERSION}' alias ansible-shell = 'base_ansible bash' alias ansible = 'base_ansible ansible' alias ansible-playbook = 'base_ansible ansible-playbook' alias ansible-vault = 'base_ansible ansible-vault' alias ansible-galaxy = 'base_ansible ansible-galaxy' The export statement gives option to specify which version of ansible we want to use. This version is equal to tags defined during the build This docker image is built with the following tags (12/2018) for both alpine and Debian jessie OS: latest 2.3 2.4 2.5 2.6 2.7","title":"Ansible using docker"},{"location":"how-to/docker-ansible/#usage","text":"Simply use your aliases, and you can override ansible default version when required $ DOCKER_ANSIBLE_VERSION = 2 .5 $ docker-ansible --version ansible 2 .5.2 config file = /Users/titom73/Scripting/ansible.projects/ansible.training.phase2/ansible.cfg configured module search path = [ u '/root/.ansible/plugins/modules' , \\ u '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/local/lib/python2.7/site-packages/ansible executable location = /usr/local/bin/ansible python version = 2 .7.14 ( default, Apr 27 2018 , 09 :37:08 ) [ GCC 4 .9.2 ]","title":"Usage"},{"location":"how-to/docker-ansible/#optional-parameters","text":"","title":"Optional parameters"},{"location":"how-to/docker-ansible/#export-aws-cli-parameters","text":"Assuming you have configured your AWS CLI, you may export your parameters with the following variables: On your local shell: export AWS_DEFAULT_REGION = 'eu-west-2' export AWS_PROFILE = 'your_aws_profile' Then, these variables are exposed to your docker instance by using --env keyword. If they are not set, then, nothing is export to your container. export DOCKER_ANSIBLE_VERSION = 2 .5 base_ansible () { docker run -it --rm \\ --env ANSIBLE_REMOTE_USER = ${ USER } \\ --env AWS_DEFAULT_REGION = ${ AWS_DEFAULT_REGION } \\ --env AWS_PROFILE = ${ AWS_PROFILE } \\ --volume $SSH_AUTH_SOCK :/ssh-agent \\ --env SSH_AUTH_SOCK = /ssh-agent \\ -v ${ PWD } :project \\ -v ${ HOME } /.aws/:/root/.aws/ \\ -v ${ HOME } /.ssh/known_hosts:/root/.ssh/known_hosts \\ -w ${ PWD } \\ inetsix/docker-ansible: ${ DOCKER_ANSIBLE_VERSION } $@ }","title":"Export AWS CLI parameters"},{"location":"how-to/docker-ansible/#overwrite-ansible-commands","text":"If for some reasons, you need to use your installed ansible version, just use \\\\ in front of any ansible command like below: $ \\a nsible --version ansible 2 .5.1 config file = /Users/titom73/Scripting/ansible.projects/ansible.training.phase2/ansible.cfg configured module search path = [ u '/Users/titom73/.ansible/plugins/modules' , \\ u '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/local/lib/python2.7/site-packages/ansible executable location = /usr/local/bin/ansible python version = 2 .7.14 ( default, Mar 22 2018 , 15 :04:47 ) \\ [ GCC 4 .2.1 Compatible Apple LLVM 9 .0.0 ( clang-900.0.39.2 )] $ ansible --version ansible 2 .5.2 config file = /Users/titom73/Scripting/ansible.projects/ansible.training.phase2/ansible.cfg configured module search path = [ u '/root/.ansible/plugins/modules' , \\ u '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/local/lib/python2.7/site-packages/ansible executable location = /usr/local/bin/ansible python version = 2 .7.14 ( default, Apr 27 2018 , 09 :37:08 ) [ GCC 4 .9.2 ]","title":"Overwrite ansible commands"},{"location":"how-to/virtual-env-python/","text":"VirtualEnv Wrapper \u00b6 VirtualEnvWrapper allows user to create python virtual-environment and use easy command to create / use / modify / delete Installation \u00b6 Use python-pip to install module: $ pip install virtualenvwrapper To test in your shell: Create folder to store virtual-environments: $ mkdir ~/.virtual-envs $ mkdir ~/Scripting/ Load vars to your shell $ export WORKON_HOME = ~/.virtual-envs $ export PROJECT_HOME = ~/Scripting/ $ source /usr/local/bin/virtualenvwrapper.sh To make a permanent configuration: $ vim ~/.zshrc export WORKON_HOME = ~/.virtual-envs export PROJECT_HOME = ~/Scripting/ source /usr/local/bin/virtualenvwrapper.sh Commands \u00b6 Create virtual environment $ mkvirtualenv my_venv List existing environments $ lsvirtualenv Load existing environment $ workon my_env Create project with a new venv $ mkproject myproject Project is created under PROJECT_HOME with a dedicated folder and a venv with project\u2019s name Leave a venv deactivate Delete a venv $ rmvirtualenv my_venv Resources \u00b6 List of commands Hooks and customisation","title":"VirtualEnv Wrapper"},{"location":"how-to/virtual-env-python/#virtualenv-wrapper","text":"VirtualEnvWrapper allows user to create python virtual-environment and use easy command to create / use / modify / delete","title":"VirtualEnv Wrapper"},{"location":"how-to/virtual-env-python/#installation","text":"Use python-pip to install module: $ pip install virtualenvwrapper To test in your shell: Create folder to store virtual-environments: $ mkdir ~/.virtual-envs $ mkdir ~/Scripting/ Load vars to your shell $ export WORKON_HOME = ~/.virtual-envs $ export PROJECT_HOME = ~/Scripting/ $ source /usr/local/bin/virtualenvwrapper.sh To make a permanent configuration: $ vim ~/.zshrc export WORKON_HOME = ~/.virtual-envs export PROJECT_HOME = ~/Scripting/ source /usr/local/bin/virtualenvwrapper.sh","title":"Installation"},{"location":"how-to/virtual-env-python/#commands","text":"Create virtual environment $ mkvirtualenv my_venv List existing environments $ lsvirtualenv Load existing environment $ workon my_env Create project with a new venv $ mkproject myproject Project is created under PROJECT_HOME with a dedicated folder and a venv with project\u2019s name Leave a venv deactivate Delete a venv $ rmvirtualenv my_venv","title":"Commands"},{"location":"how-to/virtual-env-python/#resources","text":"List of commands Hooks and customisation","title":"Resources"}]}